<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PR曲线绘制</title>
      <link href="/2023/07/28/%E7%BB%98%E5%88%B6PR%E6%9B%B2%E7%BA%BF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/07/28/%E7%BB%98%E5%88%B6PR%E6%9B%B2%E7%BA%BF%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>什么是PR曲线：用于评估分类模型性能的一种常见评估工具。</p><p>召回率：表示分类器识别所有正例样本的能力，就是原来的实际为正例有多少预测对了。TP&#x2F;TP+FN</p><p>精确率：表示分类器预测为正例的样本中实际为正例的比例，就是预测结果中有多少正例。TP&#x2F;TP+FP</p><p>PR曲线是一组(R,P)值组成，横轴是召回率，纵轴是精确率。</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.image <span class="keyword">as</span> mpimg</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.core.numeric <span class="keyword">import</span> normalize_axis_tuple</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line"><span class="keyword">from</span> scipy.interp_spline</span><br><span class="line">readDir = <span class="string">&quot;绝对路径&quot;</span></span><br><span class="line">Curve_one = [];</span><br><span class="line">Curve_two = [];</span><br><span class="line">Curve_three = [];</span><br><span class="line">Curve_four = [];</span><br><span class="line">Curve_five = [];</span><br><span class="line">drawMat = [];</span><br><span class="line">PRscore = [];</span><br><span class="line">gtMat = [];</span><br><span class="line">dataMat = [];</span><br><span class="line">scoreMat = [];</span><br><span class="line"></span><br><span class="line">det savescore(readDir):</span><br><span class="line">    f = <span class="built_in">open</span>(readDir,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    Line = f.readLine();</span><br><span class="line">    <span class="keyword">while</span> Line:</span><br><span class="line">        txt = Line.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        dataMat.append(<span class="built_in">int</span>(txt[<span class="number">0</span>]))</span><br><span class="line">        score = FLOAT(txt[<span class="number">2</span>]);</span><br><span class="line">        scoreMat.append(score);</span><br><span class="line">        line = f.readLine();</span><br><span class="line">    f.close();</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generategt</span>(<span class="params">geMat</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(dataMat),<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> i&gt;=<span class="number">2311</span> <span class="keyword">and</span> i&lt;=<span class="number">4513</span> :</span><br><span class="line">        geMat.append(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            geMat.append(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculatetruefalse</span>(<span class="params">i,drawMat,gtMat</span>):</span><br><span class="line">    A = <span class="number">0</span>;</span><br><span class="line">    B = <span class="number">0</span>;</span><br><span class="line">    C = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(dataMat), <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">float</span>(scoreMat[num]) &lt;= i:</span><br><span class="line">            drawMat.append(i);</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            drawMat.append(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (gtMat[num] == <span class="number">1</span>) <span class="keyword">and</span> (drawMa[num] == <span class="number">1</span>):</span><br><span class="line">        A = A + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (gtMat[num] == <span class="number">0</span>) <span class="keyword">and</span> (drawMa[num] == <span class="number">1</span>):</span><br><span class="line">        B = B + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (gtMat[num] == <span class="number">1</span>) <span class="keyword">and</span> (drawMa[num] == <span class="number">0</span>):</span><br><span class="line">        C = C + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (A+B != <span class="number">0</span>):</span><br><span class="line">        precious = A/(A+B);</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">        precious = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> A + C != <span class="number">0</span>:</span><br><span class="line">     recall = A/(A+C)</span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">        recall = <span class="number">0</span>;</span><br><span class="line">     PRscore.append([precious,recall])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">Curve_one</span>):</span><br><span class="line">    plt.figure();</span><br><span class="line">    plot1 = plt.plot(Curve_one[<span class="number">1</span>],Curve_one[<span class="number">0</span>],<span class="string">&#x27;r.-&#x27;</span>,linewidth = <span class="number">2.5</span>, markersize = <span class="number">1.0</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_Curve</span>(<span class="params">readDir1,drawMat,gtMat,PRscore</span>)</span><br><span class="line">savescore();</span><br><span class="line">    generategt();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">1000</span>, <span class="number">10</span>):</span><br><span class="line">        calculatetruefalse(i/<span class="number">1000</span>, drawMat, gtMat)</span><br><span class="line">        drawMat = [];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>;</span><br><span class="line">Curve_one = save_curve(readDir1,drawMat,gtMat,PRscore);</span><br><span class="line">   reset();</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen知识大全</title>
      <link href="/2023/07/26/Eigen%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/07/26/Eigen%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Eigen安装和使用"><a href="#Eigen安装和使用" class="headerlink" title="Eigen安装和使用"></a>Eigen安装和使用</h1><p>Eigen3在linux下的安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libeigen3-dev</span><br></pre></td></tr></table></figure><p>这里的<code>sudo</code>代表以管理员权限运行命令，<code>apt</code>表示<code>Ubuntu</code>和<code>Debian</code>等<code>Linux</code>系统中的包管理器，用于安装、卸载和更新软件包，install表示我们要安装一个软件包，<code>libeigen3-dev</code>表示要安装的eigen包。</p><p>linux软件包命名：在Linux系统中，软件包通常以<code>lib</code>开头，表示这是一个库（library）的包。接着是软件包的名称，这里是<code>eigen3</code>，表示这是Eigen库的第三个主要版本。最后是后缀<code>-dev</code>，表示这是开发版本（development version）的软件包，其中包含了开发所需的头文件和其他开发工具。</p><h1 id="CMakeLists-txt编写"><a href="#CMakeLists-txt编写" class="headerlink" title="CMakeLists.txt编写"></a>CMakeLists.txt编写</h1><p><code>Eigen</code>是纯用头文件搭建起来的库，非常神奇！这意味着你只能找到它的头文件，而没有.so 或.a 那样的二进制文件。 <strong>我们在使用时，只需引入 <code>Eigen </code>的头文件即可，不需要链接它的库文件（因为它没有库文件）。</strong></p><p>如果我们从github直接手动下载Eigen，没有编译它的话是用不了find_package(Eigen REQUIRE)，原因是find_package仅支持采用cmake编译后的库。那怎么办呢？考虑它的不包含库文件，我们直接用头文件即可。</p><p>我window系统里Eigen库的Core和Dense文件夹的路径是：<code>D:\Eigen</code>，若在CMakeLists.txt写下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;D:\\Eigen&quot;</span>)</span><br></pre></td></tr></table></figure><p>那cpp文件里即写<code>#include &quot;Dense&quot;</code>和<code>#include &quot;Core&quot;</code>即可。这两者路径拼接成完整的路径即可。</p><p>当在linux系统下，我们采用find_packe查找Eigen库时，前提是Eigen已安装，且经过cmake编译。</p><h1 id="Eigen使用基础"><a href="#Eigen使用基础" class="headerlink" title="Eigen使用基础"></a>Eigen使用基础</h1><h2 id="Eigen-MatrixXd-A"><a href="#Eigen-MatrixXd-A" class="headerlink" title="Eigen::MatrixXd  A"></a>Eigen::MatrixXd  A</h2><p>定义矩阵A，行列动态变化。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Dense库包含Eigen库所有的函数和类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//MatrixXd表示动态数组，初始化指定行数和列数</span></span><br><span class="line"><span class="function">Eigen::MatrixXd <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">m&lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">0</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">0</span>,<span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">0</span>) = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">m</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">4</span>;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;end;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Eigen-Matrix-A"><a href="#Eigen-Matrix-A" class="headerlink" title="Eigen::Matrix&lt;double, 3, 3&gt;  A"></a>Eigen::Matrix&lt;double, 3, 3&gt;  A</h2><p>定义了一个3*3的double类型矩阵，例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Matrix&lt;<span class="type">double</span>,<span class="number">3</span>,<span class="number">3</span>&gt; A;</span><br><span class="line">   A&lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1.1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>;</span><br><span class="line">   cout&lt;&lt;A&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1.1 2 3</span></span><br><span class="line"><span class="comment">4 4 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Eigen-Matrix-A-1"><a href="#Eigen-Matrix-A-1" class="headerlink" title="Eigen::Matrix&lt;double,dynamic,dynamic&gt; A"></a>Eigen::Matrix&lt;double,dynamic,dynamic&gt; A</h2><p>定义动态矩阵A，行列动态变化。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Eigen::Matrix&lt;<span class="type">double</span>,Dynamic,Dynamic&gt; <span class="title">A</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    A&lt;&lt;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;A&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Matrix3f-A-定义3-3float矩阵A"><a href="#Matrix3f-A-定义3-3float矩阵A" class="headerlink" title="Matrix3f A 定义3*3float矩阵A"></a>Matrix3f A 定义3*3float矩阵A</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Eigen/Dense&gt;</span><br><span class="line">USIN</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Eigen </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统下C++库安装使用</title>
      <link href="/2023/07/25/C++libraires/"/>
      <url>/2023/07/25/C++libraires/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统下C-库安装使用"><a href="#Linux系统下C-库安装使用" class="headerlink" title="Linux系统下C++库安装使用"></a>Linux系统下C++库安装使用</h1><p>细细品味：find_package查找库的规律是如此的巧妙，库的安装也是如此~给我一个库，我如何能够让find_package找到它呢？这就是本文的重点！！！</p><h1 id="C-库的安装方式"><a href="#C-库的安装方式" class="headerlink" title="C++库的安装方式"></a>C++库的安装方式</h1><p>在linux系统下库的安装方式主要有三种：</p><ol><li>使用包管理器安装：Linux系统通常有自己的软件包管理器，如apt、yum、dnf等。用户可以通过包管理器直接安装预编译的C++库，无需手动下载和编译。例如，使用<code>apt install</code>命令在Ubuntu或Debian系统上安装软件包。</li><li>手动编译和安装：用户可以手动下载库的源代码，然后自行编译和安装。这种方式相对较复杂，但提供了更多的定制选项。</li><li>手动编译不安装；通过手动编译库，设置环境变量，即可使用。</li><li>不编译直接使用：如果一个库只有头文件，例如Eigen库，直接include_directories即可。</li></ol><h1 id="使用包管理器安装"><a href="#使用包管理器安装" class="headerlink" title="使用包管理器安装"></a>使用包管理器安装</h1><p>以<code>sudo install apt libeigen3-dev</code>为例，首先我们解析一下这个语句，sudo表示获取管理员权限</p><p>apt是Linux系统的一个包管理工具，install表示安装，<code>lib+库名-dev</code> 是 Ubuntu&#x2F;Debian 系统中包含开发文件（头文件、静态库、共享库、CMake 模块等）的开发版本软件包的命名规则。其中，<code>lib</code> 是固定前缀，<code>库名</code> 是指具体的库名，<code>-dev</code> 表示这是开发版本的软件包。例如，<code>libeigen3-dev</code> 表示的是 Eigen 库的开发版本软件包，包含了头文件和其他开发所需的文件，方便在 C++ 项目中使用 Eigen 库进行编程。不需要手动编译该软件包，可以通过 <code>sudo apt install libeigen3-dev</code> 命令安装预编译好的开发版本软件包。</p><p>既然sudo install apt libeigen3-dev无需手动编译，可以直接在我们的代码中使用；那我们现在有个问题，我们cmake编译时，它是如何找到这个库的呢？这个库的安装路径是啥？谁指定的？安装完之后CMakeLists.txt中find_package是怎么找到这个库的头文件路径(XXX_INCLUDE_DIRS)和链接库(XXX_LIBRARIES)呢？如何找到的？</p><p>首先，我们要知道在Ubuntu和Debian等使用apt包管理器的Linux发行版中，apt会将软件包的文件安装到预定的目录结构下。具体安装路径取决于软件包的类型和用途。</p><p>通常情况下，预编译的二进制软件包（包括C++库和应用程序）会安装在以下目录：</p><ul><li>可执行文件（二进制文件）：<code>/usr/bin</code> 或 <code>/usr/local/bin</code></li><li>库文件（动态库和静态库）：<code>/usr/lib</code> 或 <code>/usr/local/lib</code></li><li>头文件（C++库的头文件）：<code>/usr/include</code> 或 <code>/usr/local/include</code></li></ul><p>例如，对于libeigen3-dev软件包，它是Eigen库的开发版本，头文件会安装在<code>/usr/include/eigen3</code>目录下，配置文件安装在&#x2F;usr&#x2F;lib&#x2F;cmake目录下，该目录包括Eigen3Config.cmake文件；而该配置文件正好是在find_package的搜索范围内，因此通过该方式find_package是能找到库的。</p><h2 id="手动编译和安装"><a href="#手动编译和安装" class="headerlink" title="手动编译和安装"></a>手动编译和安装</h2><p>如果我们自己去官网下载eigen或者使用git clone 下载，需要自己先编译，再进行安装，安装过程中config.cmake文件就配置好了，合理安装在find_package能找的位置；</p><p>在CMakeLists.txt所在的目录下，输入下列指令，即可安装；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">sudo make <span class="keyword">install</span></span><br></pre></td></tr></table></figure><h2 id="手动编译不安装"><a href="#手动编译不安装" class="headerlink" title="手动编译不安装"></a>手动编译不安装</h2><p>如果我们发现，某个库我手动编译完之后，我们想要用find_package安装不了咋办呢？</p><p><strong>根据find_package的查找规律</strong>：<strong>先找环境变量路径，然后在环境变量路径下找lib或者share下的cmake文件或者包名文件夹下的Config.cmake配置文件。</strong></p><p>在linux系统的主目录下，打开.bashrc文件，将该库写入到环境变量中</p><p>一般是<code>source ./devel/setup.bash</code>命令,如此将devel文件夹添加到环境变量当中，当find_package找库时，根据上面的查找规律，就会在devel文件夹下的lib或share文件夹下的cmake或该库名文件夹下的Config.cmake文件。</p><p>也就是说，当我自己下载一个库之后，编译完库后，设置一下环境变量，find_package就能使用，并找到该库的Config.cmake配置文件了。</p><h2 id="不编译，直接使用"><a href="#不编译，直接使用" class="headerlink" title="不编译，直接使用"></a>不编译，直接使用</h2><p>最常见就是engen库了，我们在CMakeLists.txt，直接指明头文件路径即可。</p><p><code>#include_directories( &quot;D:\\Eigen&quot; )</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM十四讲第1-2讲</title>
      <link href="/2023/07/24/Iris/"/>
      <url>/2023/07/24/Iris/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM十四讲第1-2讲</title>
      <link href="/2023/07/24/SLAM14%E8%AE%B2%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2023/07/24/SLAM14%E8%AE%B2%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="SLAM十四讲-第1-2讲-前言和初识SLAM"><a href="#SLAM十四讲-第1-2讲-前言和初识SLAM" class="headerlink" title="SLAM十四讲 第1-2讲 前言和初识SLAM"></a>SLAM十四讲 第1-2讲 前言和初识SLAM</h1><p>想象一下，你是一个小机器人，置身于一个完全陌生的房间里，你不知道自己在房间的哪个位置，也不知道房间的结构和布局是怎样的。你的目标是能够自主地在这个房间里行走，找到出口，并且把房间的地图画出来。SLAM就是帮助你完成这个任务的技术。它可以让你同时做两件事情：第一，实时地知道自己当前在房间里的具体位置，就像你知道自己在房间里的哪个角落；第二，边行走边把房间的地图画出来，就像你在走的时候慢慢描绘整个房间的布局。</p><p>在这之前，我们研究一下三个问题: </p><h2 id="为什么需要SLAM"><a href="#为什么需要SLAM" class="headerlink" title="为什么需要SLAM"></a>为什么需要SLAM</h2><p>当机器人、自动驾驶车辆或其他智能系统在未知的环境中行动时，就像一个陌生的地方你不知道路在哪里，SLAM 就像是它们的“眼睛”和“脑子”。</p><p>SLAM 可以帮助它们实时地了解自己的位置，就像你在地图上知道自己所处的位置一样。同时，它也能帮助它们建立地图，就像你画地图标记周围的街道和建筑物一样。</p><p>有了 SLAM，这些智能系统就能在未知的环境中自主导航，避开障碍物，找到目标位置，就像你有地图指引你一样。这样，它们就能更加智能地完成任务，安全地穿行在未知的世界里。</p><h2 id="什么是SLAM"><a href="#什么是SLAM" class="headerlink" title="什么是SLAM"></a>什么是SLAM</h2><p>SLAM 是 Simultaneous Localization and Mapping 的缩写，中文译作“同时定位与地图构建”。它是指搭载特定传感器的主体，在没有环境先验信息的情况下，于运动过 程中建立环境的模型，同时估计自己的运动 。</p><h2 id="如何用SLAM"><a href="#如何用SLAM" class="headerlink" title="如何用SLAM"></a>如何用SLAM</h2><ol><li><strong>自动驾驶汽车</strong>：SLAM技术在自动驾驶汽车中起到关键作用。通过激光雷达、摄像头等传感器数据，汽车可以实时地定位自身位置，并构建出周围环境的地图，从而实现自主驾驶和避障功能。</li><li><strong>无人机导航</strong>：SLAM技术可以用于无人机的自主导航和航迹规划。通过搭载激光雷达或视觉传感器，无人机可以实时感知周围环境，并建立地图，从而能够自主飞行和执行任务。</li><li><strong>机器人导航</strong>：在机器人导航领域，SLAM技术可以使机器人能够在未知环境中自主移动和完成任务。机器人通过感知和地图构建，可以规划路径、避障和定位自身位置。</li><li><strong>增强现实</strong>：在增强现实应用中，SLAM技术可以通过激光雷达或摄像头等传感器获取环境信息，并将虚拟内容与真实世界进行融合，使得虚拟内容与现实场景相匹配。</li><li><strong>室内定位与导航</strong>：SLAM技术可以用于室内环境的定位和导航，如在大型商场、医院、工厂等室内场所中实现人员或物品的定位和导航。</li><li><strong>虚拟现实游戏</strong>：在虚拟现实游戏中，SLAM技术可以用于将虚拟内容与真实环境进行交互，使玩家能够在现实世界中体验虚拟游戏内容。</li></ol><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>学习SLAM时，会接触Eigen、OpenCV、PCL、g2o、cere等库，要掌握它们在Linux操作系统中的使用方法。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM十四讲第1-2讲</title>
      <link href="/2023/07/24/scan%20context/"/>
      <url>/2023/07/24/scan%20context/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>Scan context 简单来说是“扫描上下文”。类似于我们阅读的时候要理解上下文，才能明白其意。Lidar SLAM在进行回环检测的时候，也需要将“上下文”进行比较，方才知道我们是不是又走到了之前的同一个地方。</p><p>该文提出了一个Scan Context这个非直方图的全局描写符。典型应用：回环检测和位置识别</p><p>Scan Context创建：</p><p>首先对Scan进行分割，生成20*60矩阵；假设现在得到一对Scan Context，求他们俩之间的相似度，文章中采用按列的距离进行计算；</p><p>假设：Iq表示当前用来查询的点云；Ic:表示用来进行匹配的候选点云；</p><p>接下来计算相似性，SC是按列进行计算；但实际上两个sc在列方向发生了水平平移，但是竖着的row方向未发生变化；怎么办，通过旋转候选点云，找到最佳的shift的旋转，再计算相似性；</p><p>上面计算最短相似性，先找到最佳旋转n，计算量很大，所以在本文中提出了一种两阶段的搜索，并提出了Ring Key这个描述子来进行匹配搜索；</p><p>由内到外，一圈一圈ring key对SC描述子的每一行进行编码变成了N维度的向量k，向量k是统计每一行row的非零数值，这样就和旋转没关系了；在得到ring key向量k之后，利用k构建KD Tree；用ring key of query到这个KD Tree中搜索K个最相似的scan indexex，得到最相似的K个scan，再计算相似性；</p><p><strong>应用：</strong>用scan context 进行ICP初始化；重定位；</p><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">返回动态矩阵  SC命名空间 域解析运算符  函数名( pcl命名空间 域解析运算符 点云类名&lt;点云类型&gt;引用符号  点云名)</span><br><span class="line">&#123;</span><br><span class="line">计时类名 对象名；</span><br><span class="line">整数类型  变量名 = 点云对象.点.尺寸;</span><br><span class="line">常量 整数类型 变量名 = -1000；</span><br><span class="line">动态数组类型 对象名 = 变量名 * 对象 域名解析符 方法名(参数名1，参数名2)；</span><br><span class="line">类名 对象名；</span><br><span class="line">浮点数类型 极坐标角度，极坐标长度；</span><br><span class="line">for(整数类型 变量名 = 0; 变量名++)&#123;</span><br><span class="line">对象的属性 = 点云的点索引的x坐标；</span><br><span class="line">对象的属性 = 点云的点的索引的y坐标；</span><br><span class="line">对象的属性 = 点云的点云的索引的z坐标 + 雷达高度；</span><br><span class="line">长度 = 开根号(对象的属性的平方+对象的属性的平方+对象的属性的平方)</span><br><span class="line">角度 = xy2theta(pt.x,pt.y);</span><br><span class="line">当 (长度超过80)&#123;</span><br><span class="line">停止当前循环;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针</title>
      <link href="/2023/07/22/hello-world/"/>
      <url>/2023/07/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针</title>
      <link href="/2023/07/22/%E5%BF%83%E5%BE%97/"/>
      <url>/2023/07/22/%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<ol><li>C++函数定义和声明需要指明参数类型，函数调用时不需要指明类型，可以传入变量名或者参数；</li></ol><p>例如：int add(int a, int b)    函数声明； 函数调用可以使用add(a,b)，也可以传入add(1,2)</p><ol start="2"><li>C++函数定义方式：返回值类型 函数名(类型  变量名，·····) {·····}</li></ol><p>例如：int add(int a, int b){return a+b};</p><ol start="3"><li><p>C++函数返回值可以直接返回一个表达，见上例；</p></li><li><p>C++ 中两个语句需要同时成立用符号 &amp;；</p></li><li><p>C++ 中如果if语句后面接一个表达式，可以不加{};</p></li><li><p>CMakeLists文件第一语句为：cmake_minimum_required(VERSION XXX)，指定cmake所需的最小版本。</p></li><li><p>CMakeLists文件第二语句为：项目名project(name)，表示项目名，这里的name等价于${PROJECT_NAME}；</p></li><li><p>CMakeLists文件add_executable(生成的二进制文件名 主函数cpp文件);</p></li><li><p>CMakeLists文件aux_source_directory(. SRC_LIST) 表示将当前目录下所有源文件存储在SRC_LIST；</p></li><li><p>CMakeLists文件 set(var [value])  将很多cpp文件或者一个很长的路径设置为一个变量var表示；</p></li><li><p>CMakeLists文件 add_library(库文件名 STATIC&#x2F;SHARED cpp)  将cpp文件编译成静态库文件；</p></li><li><p>CMakeLists文件 link_libraries(路径) 直接链接已编译好的库文件，需要包含库文件名；</p></li><li><p>CMakeLists文件 target_link_libraries(文件名 库名) 将库和文件链接，生成可执行二进制文件；</p></li><li><p>CMakeLists文件 include_directories(路径) 相对-I，指定头文件的搜索路径</p></li><li><p>CMakeLists文件 file(GLOB_RECURSE c_files $) 将文件夹下指定类型的文件用变量声明</p></li><li><p>CMakeLists文件 add_subdirectory(目录)  添加子目录，便于使用子目录中的CMakeLists变量；</p></li><li><p>CMakeLists文件 include(dir) 在给定的dir文件中加载执行CMake代码；</p></li><li><p>CMakeLists文件 list(REMOVE_ITEM ALL_SRCS  ${TEST_SRCS}); 清除${TEST_SRCS}中指定的文件；</p></li><li><p>CMakeLists文件 find_package() 找包；</p></li><li><p>CMakeLists中内置变量：**<code>PROJECT_SOURCE_DIR</code>&#x2F;<code>CMAKE_SOURCE_DIR</code>&#x2F;<code>_SOURCE_DIR</code>：** 为包含<code>PROJECT()</code>命令的最近一个<code>CMakeLists.txt</code>文件所在的文件夹路径。**<code>PROJECT_BINARY_DIR</code>&#x2F;<code>CMAKE_BINARY_DIR</code>&#x2F;<code>_BINARY_DIR</code>：** 运行<code>cmake</code>命令的目录，即工程编译发生的路径。</p></li><li><p>弧度转角度：float rad2deg(float radians) {return radians * 180 &#x2F; M_PI}</p></li><li><p>角度转弧度：float deg2rad(float degree) {return degree * M_pi &#x2F; 180}</p></li><li><p>给定xy坐标转角度：float xy2theta (const float &amp; _x,  const float &amp; _y) {</p><p>if (_x &gt;&#x3D; 0 &amp; _y&gt;&#x3D;0) return (180&#x2F;M_I) * atan(__y&#x2F;__x);</p><p>if (_x &lt;&#x3D; 0&amp; _y &gt;&#x3D; 0) return (180-180&#x2F;M_I * atan(y&#x2F;(-x)));</p><p>if (_x&lt;&#x3D; 0 &amp; _y &lt;&#x3D;0) return (180 + (180&#x2F;M_I * atan(y&#x2F;(-x)));</p><p>if (_x &gt;&#x3D; 0 &amp; _y &lt;&#x3D;0) return (360 - (180&#x2F;M_I * atan(y&#x2F;(-x)) )</p></li><li><p>MatrixXd中X表示维度，d表示double类型，表示维度不指定double类型的矩阵；</p></li><li><p>C++ 中assert(a &gt; 0) 表示a &gt; 0时成功，小于等于0时报错；</p></li><li><p>MatrixXd使用时注意加Eigen，还有程序中未链接库时，如果多此一举链接未使用的库回报错，使用&lt;&lt;输入矩阵时，逗号隔开各数字即可，不要用分号；</p></li><li><p>MatrixXd::Identity(3,3)表示生成单位矩阵；这里的I要大写，如果没使用using命名空间，需要加Eigen;</p></li><li><p>MatrixXd::Zero(3，3)表示生成零矩阵；同上；MatrixXd::Ones(3，3)表示生成全1矩阵；同上；MatrixXd::Random(3，3)表示生成随机矩阵；</p></li><li><p>MatrixXd矩阵的行数和列数:  arr.rows()行数；arr.cols()列数；这里的rows和cols小写；如果需要指定哪行哪列，则使用arr.row(1)表示arr矩阵第一行；arr.col(1)表示arr矩阵的第1列</p></li><li><p>C++ 中 % 表示取余操作，例如7 % 3 &#x3D; 1；</p></li><li><p>C++ 中进行移位操作时，要将列向右移动3位，(把当前的列ID+需要移动的位数)&#x2F;总列数 为新的列数；</p></li><li><p>C++ 范围for循环：for(auto &amp;i : vec) {cout&lt;&lt;i}; 如果for后面接一条语句，则不用加大括号；</p></li><li><p>C++中Eigen暂不支持基于范围的for循环；</p></li><li><p>vector初始化方法：vector<int> a(10); 定义10个整型元素的向量，未指定初始值；vector<int> a(10,1)指定整型元素大小为10，每个元素为1；vector<int> a(b)；将b复制给a; vector<int> a(b.begin(),b.begin()+3)定义了a值为b中第0个到第2个（共3个）元素；vector<int> a(b,b+7); &#x2F;&#x2F;从数组中获得初值</p></li><li><p>将eigen矩阵转换为vector向量：std::vector<float> vec(arr.data(),_arr.data()+arr.size())，arr是一个eigen矩阵;</p></li><li><p>eigen.data()返回eigen矩阵中第一个元素的内存位置；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="/2023/07/22/ROS/"/>
      <url>/2023/07/22/ROS/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><h2 id="1243124"><a href="#1243124" class="headerlink" title="1243124"></a>1243124</h2><p>cmake_minimum_required(VERSION 2.8.3)<br>project(lio_sam)</p><p>set(CMAKE_BUILD_TYPE “Release”)<br>set(CMAKE_CXX_FLAGS “-std&#x3D;c++11”)<br>set(CMAKE_CXX_FLAGS_RELEASE “-O3 -Wall -g -pthread”)</p><p>find_package(catkin REQUIRED COMPONENTS<br>  tf<br>  roscpp<br>  rospy<br>  cv_bridge</p><h1 id="pcl-library"><a href="#pcl-library" class="headerlink" title="pcl library"></a>pcl library</h1><p>  pcl_conversions</p><h1 id="msgs"><a href="#msgs" class="headerlink" title="msgs"></a>msgs</h1><p>  std_msgs<br>  sensor_msgs<br>  geometry_msgs<br>  nav_msgs<br>  message_generation<br>  visualization_msgs<br>)</p><p>find_package(OpenMP REQUIRED)<br>find_package(PCL REQUIRED QUIET)<br>find_package(OpenCV REQUIRED QUIET)<br>find_package(GTSAM REQUIRED QUIET)<br>find_package(Boost REQUIRED COMPONENTS timer)</p><p>add_message_files(<br>  DIRECTORY msg<br>  FILES<br>  cloud_info.msg<br>)</p><p>add_service_files(<br>  DIRECTORY srv<br>  FILES<br>  save_map.srv<br>)</p><p>generate_messages(<br>  DEPENDENCIES<br>  geometry_msgs<br>  std_msgs<br>  nav_msgs<br>  sensor_msgs<br>)</p><p>catkin_package(<br>  INCLUDE_DIRS include<br>  DEPENDS PCL GTSAM</p><p>  CATKIN_DEPENDS<br>  std_msgs<br>  nav_msgs<br>  geometry_msgs<br>  sensor_msgs<br>  message_runtime<br>  message_generation<br>  visualization_msgs<br>)</p><h1 id="include-directories"><a href="#include-directories" class="headerlink" title="include directories"></a>include directories</h1><p>include_directories(<br>    include<br>    ${catkin_INCLUDE_DIRS}<br>    ${PCL_INCLUDE_DIRS}<br>  ${OpenCV_INCLUDE_DIRS}<br>    ${GTSAM_INCLUDE_DIR}<br>)</p><h1 id="link-directories"><a href="#link-directories" class="headerlink" title="link directories"></a>link directories</h1><p>link_directories(<br>    include<br>    ${PCL_LIBRARY_DIRS}<br>  ${OpenCV_LIBRARY_DIRS}<br>  ${GTSAM_LIBRARY_DIRS}<br>)</p><p>###########</p><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>###########</p><h1 id="Range-Image-Projection"><a href="#Range-Image-Projection" class="headerlink" title="Range Image Projection"></a>Range Image Projection</h1><p>add_executable(${PROJECT_NAME}_imageProjection src&#x2F;imageProjection.cpp)<br>add_dependencies(${PROJECT_NAME}_imageProjection ${catkin_EXPORTED_TARGETS} ${PROJECT_NAME}_generate_messages_cpp)<br>target_link_libraries(${PROJECT_NAME}_imageProjection ${catkin_LIBRARIES} ${PCL_LIBRARIES} ${OpenCV_LIBRARIES})</p><h1 id="Feature-Association"><a href="#Feature-Association" class="headerlink" title="Feature Association"></a>Feature Association</h1><p>add_executable(${PROJECT_NAME}_featureExtraction src&#x2F;featureExtraction.cpp)<br>add_dependencies(${PROJECT_NAME}_featureExtraction ${catkin_EXPORTED_TARGETS} ${PROJECT_NAME}_generate_messages_cpp)<br>target_link_libraries(${PROJECT_NAME}_featureExtraction ${catkin_LIBRARIES} ${PCL_LIBRARIES} ${OpenCV_LIBRARIES})</p><h1 id="Mapping-Optimization"><a href="#Mapping-Optimization" class="headerlink" title="Mapping Optimization"></a>Mapping Optimization</h1><p>add_executable(${PROJECT_NAME}_mapOptmization src&#x2F;mapOptmization.cpp)<br>add_dependencies(${PROJECT_NAME}_mapOptmization ${catkin_EXPORTED_TARGETS} ${PROJECT_NAME}_generate_messages_cpp)<br>target_compile_options(${PROJECT_NAME}_mapOptmization PRIVATE ${OpenMP_CXX_FLAGS})<br>target_link_libraries(${PROJECT_NAME}_mapOptmization Boost::timer ${catkin_LIBRARIES} ${PCL_LIBRARIES} ${OpenCV_LIBRARIES} ${OpenMP_CXX_FLAGS} gtsam)</p><h1 id="IMU-Preintegration"><a href="#IMU-Preintegration" class="headerlink" title="IMU Preintegration"></a>IMU Preintegration</h1><p>add_executable(${PROJECT_NAME}_imuPreintegration src&#x2F;imuPreintegration.cpp)<br>target_link_libraries(${PROJECT_NAME}_imuPreintegration Boost::timer ${catkin_LIBRARIES} ${PCL_LIBRARIES} ${OpenCV_LIBRARIES} gtsam)</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Ros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeLists.txt入门到大成</title>
      <link href="/2023/07/22/CMakeLists/"/>
      <url>/2023/07/22/CMakeLists/</url>
      
        <content type="html"><![CDATA[<h1 id="CMakeLists-txt编写入门"><a href="#CMakeLists-txt编写入门" class="headerlink" title="CMakeLists.txt编写入门"></a>CMakeLists.txt编写入门</h1><p>借用黑格尔的名言“<strong>存在即合理</strong>”，既然CMakeList.txt被设计出来，就有它的一个道理！这样想来！我们内心对它的畏惧是不是就减少了呢！那~现在让我们从“它为什么存在”，“它是什么”以及“它怎么用”三个角度深刻剖析！</p><hr><h2 id="为什么存在？"><a href="#为什么存在？" class="headerlink" title="为什么存在？"></a>为什么存在？</h2><p>我们刚开始学C++中的“Hello World”时，是通过用g++编译器对该cpp进行编译生成可执行文件(g++ main.cpp -o main)。当涉及大型项目，需要用到大量库的时候，采用这种编译方式是极其繁琐的。因此，能不能用一个脚本文件来编译源代码文件，于是Makefile作为一个自动化编译脚本应运而生。然而，它语法实在过于繁琐，如果能有更简单的配置文件就好，能自动化生成Makefile文件。所以，CMakeLists.txt(Cmake)就设计出来了。当然，这只是其中的部分原因，更重要的是有了它，我们能在不同操作系统运行(与操作系统解耦)，也就是别人写的代码，也能在我的操作系统上编译运行。</p><p>看到这，大家的思路应该也清晰了，总结一下：CMakeLists.txt存在的原因是：</p><ol><li><strong><font color = "red">解决跨平台编译问题</strong></font></li><li><strong><font color = "red">使项目构建过程更简单、灵活</font></strong></li></ol><p><strong>历史渊源：</strong>在早期，开发人员需要针对每个平台编写不同的构建系统脚本，例如Makefile（Unix-like系统）、Visual Studio项目文件（Windows）等。这导致了构建过程的繁琐和维护困难，特别是对于跨平台项目。为了解决这个问题，CMake在2000年由Kitware公司开发出来。</p><p><strong>注</strong>：</p><p><strong>常见操作系统：</strong>(<strong><font color = 'red'>系统软件；硬件和软件的中介；提供管理硬件接口</strong></font>)</p><p>Window: 微软开发，用于个人电脑和服务器系统</p><p>Linux: 基于开源Linux内核的操作系统，有许多不同的发行版，如Ubuntu、Debian、Fedora、CentOS等</p><p>Unix: 多用户、多任务的操作系统家族，包括类似BSD、Solaris等不同的版本</p><p>macOS: 苹果开发，用于苹果的Mac系列电脑</p><p>iOS: 苹果 开发，用于iPhone、iPad和iPod Touch</p><p>Android: 谷歌开发，用于智能手机和平板电脑</p><p><strong>系统脚本：</strong>一种计算机程序。（程序由指令组成，指令像命令)</p><p><strong>Makefile：</strong>一种自动化编译的脚本文件，定义了项目的构建规则和依赖关系。</p><p><strong>Make:</strong> 一种自动化构建和编译工具。Make根据这个Makefile来判断哪些文件需要重新编译，然后调用相应的编译器（例如g++）来完成编译过程。</p><p><strong>Cmake:</strong> 一种跨平台的开源构建工具。</p><p><strong>CMakeLists.txt:</strong> 是Cmake的脚本文件</p><p><strong>关系：</strong>CMakeList.txt通过Cmake指令来生成Makefile文件，Makefile文件再通过make指令自动化编译C++源代码。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>CMakeLists: 是一个脚本文件，通过CMake指令编写，允许开发者灵活地配置和管理C&#x2F;C++项目的构建过程。使用CMakeLists.txt文件，开发者可以实现一次编写，多平台编译的效果，方便地在不同操作系统和编译器上构建项目，从而提高项目的可移植性和开发效率。</p><p>CMake：是一个跨平台的构建工具，用于生成适用于不同操作系统和编译器的本地构建文件（如Makefile、Visual Studio项目文件等）。CMake使用一个名为”CMakeLists.txt”的脚本文件来描述项目的构建配置。通过CMake，开发者可以将项目的构建过程和依赖管理与特定的编译器和操作系统解耦，从而实现跨平台的构建支持。</p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>先来个复杂的CMakeLists文件，先直观上感受一下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(lio_sam)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Release&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-std=c++11&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3 -Wall -g -pthread&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  tf</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  cv_bridge</span><br><span class="line">  <span class="comment"># pcl library</span></span><br><span class="line">  pcl_conversions</span><br><span class="line">  <span class="comment"># msgs</span></span><br><span class="line">  std_msgs</span><br><span class="line">  sensor_msgs</span><br><span class="line">  geometry_msgs</span><br><span class="line">  nav_msgs</span><br><span class="line">  message_generation</span><br><span class="line">  visualization_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(OpenMP REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(PCL REQUIRED QUIET)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED QUIET)</span><br><span class="line"><span class="keyword">find_package</span>(GTSAM REQUIRED QUIET)</span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED COMPONENTS timer)</span><br><span class="line"></span><br><span class="line">add_message_files(</span><br><span class="line">  DIRECTORY msg</span><br><span class="line">  FILES</span><br><span class="line">  cloud_info.msg</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_service_files(</span><br><span class="line">  DIRECTORY srv</span><br><span class="line">  FILES</span><br><span class="line">  save_map.srv</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  geometry_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">  nav_msgs</span><br><span class="line">  sensor_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">catkin_package(</span><br><span class="line">  INCLUDE_DIRS <span class="keyword">include</span></span><br><span class="line">  DEPENDS PCL GTSAM</span><br><span class="line"></span><br><span class="line">  CATKIN_DEPENDS</span><br><span class="line">  std_msgs</span><br><span class="line">  nav_msgs</span><br><span class="line">  geometry_msgs</span><br><span class="line">  sensor_msgs</span><br><span class="line">  message_runtime</span><br><span class="line">  message_generation</span><br><span class="line">  visualization_msgs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># include directories</span></span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line"><span class="keyword">include</span></span><br><span class="line"><span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line"><span class="variable">$&#123;PCL_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span></span><br><span class="line"><span class="variable">$&#123;GTSAM_INCLUDE_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># link directories</span></span><br><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line"><span class="keyword">include</span></span><br><span class="line"><span class="variable">$&#123;PCL_LIBRARY_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBRARY_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;GTSAM_LIBRARY_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="comment">## Build ##</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Range Image Projection</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_imageProjection src/imageProjection.cpp)</span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_imageProjection <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_imageProjection <span class="variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Association</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_featureExtraction src/featureExtraction.cpp)</span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_featureExtraction <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_featureExtraction <span class="variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mapping Optimization</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_mapOptmization src/mapOptmization.cpp)</span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_mapOptmization <span class="variable">$&#123;catkin_EXPORTED_TARGETS&#125;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"><span class="keyword">target_compile_options</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_mapOptmization PRIVATE <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_mapOptmization Boost::timer <span class="variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenMP_CXX_FLAGS&#125;</span> gtsam)</span><br><span class="line"></span><br><span class="line"><span class="comment"># IMU Preintegration</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_imuPreintegration src/imuPreintegration.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_imuPreintegration Boost::timer <span class="variable">$&#123;catkin_LIBRARIES&#125;</span> <span class="variable">$&#123;PCL_LIBRARIES&#125;</span> <span class="variable">$&#123;OpenCV_LIBRARIES&#125;</span> gtsam)</span><br></pre></td></tr></table></figure><hr><p>对于单个cpp文件，例如Hello World，CMakeLists.txt文件如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(Main)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>在cmd终端输入下面指令即可运行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">./main</span><br></pre></td></tr></table></figure><p>​当我们安装了比较低的CMake时，试图编译高版本CMake的CMakeLists脚本文件，CMake 将会检测到版本不匹配，并报告错误。这是因为高版本的 CMakeLists.txt 可能包含了较低版本 CMake 不支持的新特性和语法。那该如何提醒告知开发人员呢？于是下列指令便产生：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong><strong>作用：指定项目构建所需的最低 CMake 版本</strong></strong>。例如，<code>cmake_minimum_required(VERSION 3.10)</code> 表示项目需要 CMake 3.10 或更高版本才能构建，安装低于该版本的便报错！</p><p>万物皆有名字，于是<code>project(name)</code>诞生了，它是给咱们项目取的名字。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(Main)</span><br></pre></td></tr></table></figure><p>当你在命令行中运行CMake命令时，CMake会读取项目根目录下的CMakeLists.txt文件，并解析其中的内容。在这个过程中，CMake会自动生成一些内置变量，例如<code>CMAKE_SOURCE_DIR</code>、<code>CMAKE_BINARY_DIR</code>等，用于指示项目的源代码目录和构建目录的路径。常见内置变量如下：</p><ol><li><code>CMAKE_SOURCE_DIR</code>：当前 CMakeLists.txt 所在的源码目录的根路径。</li><li><code>CMAKE_BINARY_DIR</code>：构建目录的根路径，即构建生成的可执行文件、库和其他构建输出的存放位置。</li><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：当前处理的 CMakeLists.txt 所在的源码目录的路径。</li><li><code>CMAKE_CURRENT_BINARY_DIR</code>：当前处理的 CMakeLists.txt 所在的构建目录的路径。</li><li><code>CMAKE_CURRENT_LIST_DIR</code>：当前处理的 CMakeLists.txt 所在的路径（源码目录或构建目录）。</li><li><code>CMAKE_CURRENT_LIST_LINE</code>：当前正在处理的 CMakeLists.txt 的行号。</li><li><code>CMAKE_MODULE_PATH</code>：一个用于指定额外的 CMake 模块（.cmake 文件）的搜索路径的列表。</li><li><code>CMAKE_INCLUDE_CURRENT_DIR</code>：如果设置为 <code>ON</code>，则在构建过程中自动将当前处理的 CMakeLists.txt 所在的目录添加到包含路径中。</li><li><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code>：库文件的输出目录。</li><li><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code>：可执行文件的输出目录</li></ol><p>第三行指令<code>add_executable</code>是将一个或多个源文件编译成可执行文件，有了它我们就能将C++生成可执行文件了</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(可执行文件名 cpp文件)</span><br></pre></td></tr></table></figure><p>假设现在我们自己定义了一个库并且使用它，我们该如何编写CMakeLists文件？</p><p>Main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hello.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> *argv)</span></span>&#123;</span><br><span class="line">  <span class="built_in">Hello</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义库：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>库头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>文件组织形式：</p><p>先端上CMakeLists结果：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"><span class="keyword">add_library</span>(shard_hello Hello.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> shard_hello)</span><br></pre></td></tr></table></figure><p>分别多了<code>add_library()</code>和<code>target_link_libraries()</code>，它俩有啥用呢？</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(shard_hello Hello.cpp)</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(库名 cpp文件名)</span><br></pre></td></tr></table></figure><p><code>add_library</code>作用：将Hello.cpp文件生成shard_hello 库文件，这个库文件会生成在哪文件夹里，默认是生成在build文件夹下，也是执行cmake的文件夹；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(可执行文件名 库的路径绝对或相对)</span><br></pre></td></tr></table></figure><p><code>target_link_libraries</code>作用：将该库与其他目标（如可执行文件或其他库）进行链接；它怎么找到我指定的库文件呢？</p><ol><li>CMake 会首先在当前构建目录中查找要链接的库文件。这是因为 <code>add_library()</code> 命令生成的库文件默认会位于当前构建目录中。</li><li>如果在 <code>target_link_libraries()</code> 命令中直接指定了库的绝对路径或相对路径，CMake 将会使用这个路径来链接库文件，而不再进行其他查找。</li><li>库连接查找顺序：<ul><li>如果在前两步中找不到要链接的库文件，CMake 将按照默认的库文件搜索路径进行查找。这些默认搜索路径可能包括系统标准路径和其他指定的路径。</li><li>系统标准路径：CMake 会在系统预定义的标准路径中查找库文件，这些路径通常是编译器和操作系统默认的库搜索路径。例如，在 Linux 上，通常会在 <code>/usr/lib</code>、<code>/usr/local/lib</code> 等目录中查找。</li><li><code>CMAKE_LIBRARY_PATH</code> 变量：您可以在 CMakeLists.txt 文件中使用 <code>set()</code> 命令设置 <code>CMAKE_LIBRARY_PATH</code> 变量，指定额外的库文件搜索路径。CMake 会在这些路径中查找库文件。</li><li><code>CMAKE_PREFIX_PATH</code> 变量：这个变量通常用于指定第三方库的安装路径。CMake 会在 <code>CMAKE_PREFIX_PATH</code> 变量指定的路径中查找库文件。</li><li>如果前面的步骤中找不到要链接的库文件，CMake 将根据库名字及库文件后缀来查找。CMake 会依次查找不同后缀的库文件（如 <code>.lib</code>、<code>.a</code>、<code>.dll</code> 等），直到找到匹配的库文件。</li></ul></li></ol><p>假设我们现在自己生成了库文件怎么办呢？下面是将Hello.cpp生成库文件Hello.a:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -c Hello.cpp -o Hello.o</span><br><span class="line">ar rcs Hello.a Hello.o    </span><br></pre></td></tr></table></figure><p>这时候我们可以使用<code>link_librarie</code>，例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(<span class="string">&quot;C:\\Users\\zhouwei\\Desktop\\c++\\Hello.a&quot;</span>)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(<span class="string">&quot;C:/Users/zhouwei/Desktop/c++/Hello.a&quot;</span>)</span><br></pre></td></tr></table></figure><p>在window下，上面的路径加不加双引号都可以的。</p><p>注：</p><p>静态库：库的代码会在编译时被复制并链接到可执行文件中，形成一个独立的可执行文件。静态库的优点是在运行时不需要依赖外部的库文件，使得可执行文件独立于系统环境运行。</p><p>动态库：库的代码在编译时不会被复制到可执行文件中，而是在运行时由操作系统加载到内存中，多个程序可以共享同一个动态库。动态库的优点是节省了磁盘空间，并且在多个程序之间共享，减少了系统资源的浪费。</p><p>window系统静态库和动态库后缀分别为<code>.lib</code>和<code>.dll</code>;</p><p>linux系统里静态库和动态库后缀分别为<code>.a</code>和<code>.so</code>,</p><p>C++中window绝对路径表示：例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file1</span><span class="params">(<span class="string">&quot;C:\\Users\\user\\data\\example.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>C++中window相对路径表示：例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file1</span><span class="params">(<span class="string">&quot;.\\data\\example.txt&quot;</span>)</span></span>; </span><br></pre></td></tr></table></figure><p>C++中linux绝对路径表示，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file1</span><span class="params">(<span class="string">&quot;/home/user/data/example.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>C++中linux相对路径表示，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">file1</span><span class="params">(<span class="string">&quot;./data/example.txt&quot;</span>)</span></span>; </span><br></pre></td></tr></table></figure><p>不过，仅有.a 或.so 库文件的 话，我们并不知道它里头的函数到底是什么，调用的形式又是什么样的。为了让别人（或者自己）使用这个库，我们需要提供一个头文件，说明这些库里都有些什么。因此，对于库的使用者，只要拿到了头文件和库文件，就可以调用这个库了。</p><p>说到这，不得不提一下<code>include_directories</code>这个命令；</p><p>当我们在main函数中引入<code>#include &quot;Hello.h&quot;</code>头文件之后，它是怎么找到该头文件呢？</p><p>首先它会在源码所在文件夹，即main.cpp所在的文件夹中查找，然后搜索<code>-I</code>指定的目录，接着搜索环境变量<code>C_INCLUDE_PATH</code>，<code>CPLUS_INCLUDE_PATH</code> 和 <code>CPATH</code> 指定的目录，最后搜索编译器内定的目录。</p><p>接着上面的Hello程序，我们将Hello.h头文件单独放入到include文件中，此时编译失败，无法找到该头文件，该怎么办呢？</p><p>两种解决方案：</p><p>方案一：</p><p>头文件改为如下，在CMakeLists.txt不写<code>include_directories</code>命令；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/Hello.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>方案二：</p><p>在CMakeLists.txt写<code>include_directories</code>命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_dirctories(<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><p>总结：</p><p><code>include_directories(dir)</code>等同于<code>-I</code>指令，用于指定头文件搜索路径，当include自己搜索不到头文件时，我们就可以使用它了，其中<code>dir</code>表示相对路径。</p><hr><p>上面将CMakeLists.txt中基本的命令说完了，回想一下下面命令的用法呀~</p><p><code>include_directories</code>,<code>add_libraries</code>,<code>target_link_libraries()</code>，<code>link_libraries</code>和<code>add_executable</code>。</p><p>接下来我们学习一下<code>find_package</code>指令，用法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(package_name [version] [EXACT] [QUIET] [REQUIRED] [COMPONENTS components...])</span><br></pre></td></tr></table></figure><p>这里的<code>package_name</code>是区分大小写的(例如把<code>OpenCV</code>写成opencv找不到该文件)，<code>version</code>指定查找库的版本，<code>EXACT</code>表示指定了该标准，则查找的库版本必须和指定版本一致，<code>QUIET</code>表示不输出查找信息，<code>REQUIRED</code>表示找不到就报错，<code>COMPONENTS components... </code>指定查找的库的组件。</p><p>那是如何查找的呢？</p><p><code>find_package</code>有两种搜索模式，分别是<code>Module</code>和<code>Config</code>模式</p><p>默认采用<code>Module</code>,该模式在<code>CMAKE_MODULE_PAHT</code>和<code>CMAKE_ROOT</code>变量对应的路径下搜索，前者默认为空，后者则为<code>CMake</code>安装目录下，我电脑为<code>/usr/share/cmake-3.16</code>;</p><p>若前一种模式未搜索到，则使用<code>Config</code>模式搜索，搜索方式如下：</p><ol><li>查找根目录</li></ol><ul><li><p>查找<code>&lt;PackageName&gt;_DIR</code>的CMake变量或者环境变量，默认为空；</p></li><li><p>查找名为<code>CMAKE_PREFIX_PATH</code>、<code>CMAKE_FRAMEWORK_PATH</code>、<code>CMAKE_APPBUNDLE_PATH</code>的CMake变量或<strong>环境变量</strong>路径，默认均为空；</p></li><li><p>搜索<code>PATH</code>变量下各路径，先找该路径下是否有<code>&lt;PackageName&gt;Config.cmake</code>或<code>&lt;lower-case-package-name&gt;-config.cmake</code>的模块文件，如果该路径如果以bin或sbin结尾，则<strong>自动回退到上一级目录</strong>。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $PATH</span><br><span class="line">/opt/ros/noetic/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/names:/snap/bin</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>上面均是根目录，找到根目录后，cmake会检查这些目录下的文件：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/ </span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib|share)/&lt;name&gt;*/(cmake|CMake)/</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;prefix&gt;</code>表示上面查找的路径<code>&lt;arch&gt;</code>表示系统架构，例如ubuntu系统下一般是：<code>x86_64-linux-gnu</code>，<code>(lib/&lt;arch&gt;|lib|share)</code>表示可选路径，<name>*表示区分大小，且它为包的名字。举个例子若在<code>ubuntu</code>系统下查找<code>opencv</code>库，会查找<code>/usr/lib/x86_64-linux-gnu/OpenCV/</code>、<code>/usr/lib/x86_64-linux-gnu/cmake/OpenCV/</code>、<code>/usr/lib/x86_64-linux-gnu/lib/share/OpenCV/</code>、<code>/usr/lib/x86_64-linux-gnu/share/OpenCV/</code>等。</p><p>在我ubuntu系统的电脑上，我通过该方法，顺利在<code>/usr/lib/x86_64-linux-gnu/cmake/OpenCV</code>找到opencvConfig.cmake文件，该文件里定义了变量&#96;&#96;OpenCV_INCLUDE_DIRS<code>为</code>OpenCV<code>库头文件包含路径，</code>OpenCV_LIBS<code>为</code>OpenCV&#96;链接库路径。这样一来，我们就可以使用在前面说的命令中使用opencv的头文件变量和链接库变量了。</p><p>现在回过头来看查找路径的根目录。我认为最重要的一个是PATH。由于<code>/usr/bin/</code>在PATH中，cmake会自动去<code>/usr/(lib/&lt;arch&gt;|lib|share)/cmake/&lt;name&gt;*/</code>寻找模块，这使得绝大部分我们直接通过apt-get安装的库可以被找到。</p><p>总结：库在采用<code>cmake</code>编译时，会生成<code>xxxConfig.cmake</code>文件(xxx表示库名)，该文件中定义了变量<code>xxx_INCLUDE_DIRS</code>和<code>xxx_LIBRARIES</code>的路径。也就是只要找到<code>xxxConfig.cmake</code>文件，我们就能包含头文件以及链接库了。所以<code>find_package</code>就是为此而诞生的，根据上述搜索方法，顺利找到<code>xxxConfig.cmake</code>配置文件后，会将配置文件的路径定义给<code>OpenCV_DIR</code>。如此一来，每个库的”三兄弟“路径关系便很清晰了。</p><p>注：</p><ol><li>使用<code>find_package</code>(包名，REQUIRED)这里的包名是严格区分大小写的；例如<code>OpenCV</code>写成<code>opencv</code>便找不到<code>OpenCVConfig.cmake</code>配置文件了，再如Eigen3写成eigen3也是找不到eigen3库的；</li><li>包的三兄弟<code>$&#123;xxx_DIR&#125;</code>、<code>$&#123;xxx_INCLUDE_DIRS&#125;</code>和<code>$&#123;xxx_LIBS&#125;</code>也区分大小的；例如<code>$&#123;OpenCV_libs&#125;</code>和<code>$&#123;oPEN_CV_LIBS&#125;</code>是不一样的，链接时会报错,t，通过测试发现xxx写库名或者xxx全部大写是能找到包的；</li><li>如果编译代码时，发现<code>xxxConfig.cmake</code>找不到，说明该库没有编译(默认已安装该库且库大小写没写错)，因为编译该库会生成该库的配置文件，一旦在<code>CMakeLists</code>中使用<code>find_package</code>命令，根据以上介绍内容绝对能找到！因此，回过头找到该库单独编译一下或者放到准备编译某代码的同一路径下一起编译！</li></ol><p><strong>实战：</strong>在SLAM诸多算法中，在<code>CMakeLists</code>文件常常看到这一句<code>find_package(catkin REQUIRED COMPONENTS tf roscpp ...)</code>，这该如何理解呢？首先根据上述方法，我在PATH路径下，即：<code>/opt/ros/noetic/share/catkin/cmake/</code>路径下，找到<code>catkinConfig.cmake</code>文件，该文件中定义了<code>catkin_LIBRARIES</code>和<code>catkin_INCLUDE_DIRS</code>，现在大哥都找到了，各小弟找到有难度吗？</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
